package problemComponents;

import java.util.ArrayList;

import compositeFeatureDistanceStrategies.CompositeDistanceStrategy;
import compositeFeatureDistanceStrategies.EuclideanDistance;
import simpleFeatureDistanceStrategies.SimpleDistanceStrategy;

/**
 * Composite Features are features built out of other features. With simple features and the ability 
 * to nest composite features, any type of data should be able to be included.
 * 
 * Made up of a list of features, which can either be more composite features or simple features, and a 
 * strategy to use for measuring the distance between 2 composite features with eaqual composition.
 * 
 * Has getters and setters, a method to add another features to this composite, and a toString and toXML.
 * 
 * @author luke newton
 */
public class CompositeFeature implements Feature {
	//autogenerated serialization ID for saving object to a file
	private static final long serialVersionUID = -3416586507991308648L;
	//the list of sub-features within this feature
	private ArrayList<Feature> contents;
	//the strategy used to compare this feature to others
	private CompositeDistanceStrategy distanceStrategy;
	
	/*Constructor for an empty Composite Feature*/
	public CompositeFeature(){
		contents = new ArrayList<>();
	}
	
	/* 
	 * Constructor
	 * 
	 * @param features a list of the sub-features which make up a composite feature
	 * @param strategy the method by which composite features with the same composition of this feature are compared
	 */
	public CompositeFeature(ArrayList<Feature> features, CompositeDistanceStrategy strategy){
		contents = features;
		distanceStrategy = strategy;
	}
	
	/* (non-Javadoc)
	 * @see problemComponents.Feature#calculateDistance(java.lang.Object)
	 */
	@Override
	public double calculateDistance(Feature otherFeature){
		return distanceStrategy.calculateDistance(this, (CompositeFeature)otherFeature);
	}
	
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		ArrayList<Feature> oContents = ((CompositeFeature) obj).getContents();
		int maxSize =  Math.min(contents.size(), oContents.size());
	
		for(int i = 0; i < maxSize; i++){
			if(!contents.get(i).equals(oContents.get(i)))
				return false;
		}
		return true;
	}

	@Override
	public String toString() {
		StringBuffer buf = new StringBuffer();
		buf.append("(" + contents.get(0));
		
		for(int i = 1; i < contents.size(); i++)
			buf.append("," + contents.get(i));
		
		buf.append(")");
		
		return buf.toString();
	}
	
	/** returns the feature at a specified index value, null if invalid range*/
	public Feature getFeature(int i) {
		if(i < contents.size() && i >= 0)
			return contents.get(i);
		return null;
	}
	
	/** add another feature to the contents of this feature */
	public void addFeature(Feature feature){
		contents.add(feature);
	}
	
	/**
	 * Convert string into appropriate field type. Composite features must be enclosed in
	 * round brackets, with each sub-feature separated by a comma
	 * 
	 * @param s user text input of a field value
	 * @return a feature object containing data parsed from the input string
	 */
	public static Feature parseFeature(String s){
		if(s.equals(""))
			return null;

		//if enclosed in round brackets, its a composite feature
		if(s.charAt(0) == '(' && s.charAt(s.length()-1) == ')'){
			//build feature with this
			CompositeFeature compFeature = new CompositeFeature();
			compFeature.setDistanceFunction(new EuclideanDistance());
			//remove outer brackets from string
			String sNoBrackets = s.substring(1, s.length()-1);
			//split up sub-features by comma separation, unless were in a nested composite feature
			ArrayList<String> subFeatures = new ArrayList<>();
			subFeatures.add("");
			int inANestedFeature = 0;
			for(int i = 0 ,j = 0; i < sNoBrackets.length(); i++){

				//go to next substring on commas and when not in a nested composite feature
				if(sNoBrackets.charAt(i) == ',' && inANestedFeature == 0){
					j++;
					subFeatures.add("");
					//skip space
					i+=2;
				}

				if(sNoBrackets.charAt(i) == '('){
					inANestedFeature++;
				} else if (sNoBrackets.charAt(i) == ')'){
					inANestedFeature--;
				}

				subFeatures.set(j, (subFeatures.get(j) + sNoBrackets.charAt(i)));
			}

			//parse each sub string
			for(int i = 0; i < subFeatures.size(); i++){
				compFeature.addFeature(CompositeFeature.parseFeature(subFeatures.get(i)));
			}

			return compFeature;
		} else{
			//not enclosed in round brackets, should be a simple feature
			return SimpleFeature.parseSimpleFeature(s);
		}
	}
	
	/** return the set of features contained in this feature */
	@Override
	public ArrayList<Feature> getContents() {
		return contents;
	}
	
	/** set contents of this feature to a set of features */
	public void setContents(ArrayList<Feature> contents) {
		this.contents = contents;
	}
	
	/** return the strategy used to compare features of this composition */
	public CompositeDistanceStrategy getDistanceFunction() {
		return distanceStrategy;
	}
	
	/** set the strategy used to compare features of this composition */
	public void setDistanceFunction(CompositeDistanceStrategy distanceFunction) {
		this.distanceStrategy = distanceFunction;
	}

	/* (non-Javadoc)
	 * @see problemComponents.Feature#setDistanceFunction(simpleFeatureDistanceStrategies.SimpleDistanceStrategy, problemComponents.SimpleFeatureType)
	 */
	@Override
	public void setDistanceFunction(SimpleDistanceStrategy distanceFunction, SimpleFeatureType simpleFeatureType) {
		for(int i = 0; i < contents.size(); i++){
			contents.get(i).setDistanceFunction(distanceFunction, simpleFeatureType);
		}
	}
}
